{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"vue实现excel导入导出","slug":"vue实现excel导入导出","date":"2022-08-20T15:37:36.000Z","updated":"2022-08-22T01:59:47.832Z","comments":true,"path":"2022/08/20/vue实现excel导入导出/","link":"","permalink":"http://example.com/2022/08/20/vue%E5%AE%9E%E7%8E%B0excel%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/","excerpt":"vue项目的excel的导入与导出 在做人力资源管理的后台项目时，实现了excel表的导入导出功能。用到了vue-element-admin提供的框架链接地址我们只需要在自己的项目中封装改造即可下面，来讲一下在项目中实现excel表的导入与导出的步骤。","text":"vue项目的excel的导入与导出 在做人力资源管理的后台项目时，实现了excel表的导入导出功能。用到了vue-element-admin提供的框架链接地址我们只需要在自己的项目中封装改造即可下面，来讲一下在项目中实现excel表的导入与导出的步骤。 一、excel的导入1.excel导入功能需要使用npm包xlsx，所以需要安装xlsx插件1npm i xlsx 2.将vue-element-admin提供的导入功能新建一个公共组件 ，将组件引入到我们的页面中（为了让我们的项目每次跳转都跳转到一个统一的页面，我们的项目中封装了单独的路由和页面组件@&#x2F;views&#x2F;import&#x2F;index.vue来放excel导入） 注意：这个页面结构用到了element-ui框架，但是如果用的是其他框架只需要改页面结构，逻辑代码是通用的。 @&#x2F;components&#x2F;UploadExcel&#x2F;index.vue 代码到链接中复制即可，要改动的只有页面结构和样式。（代码地址） 3.实现excel的导入在我们的import&#x2F;index.vue组件中，传给UploadExcel&#x2F;index.vue一个onsuccess方法，在这个方法里面我们可以拿到excel表的header表头和results表格数据。拿到这些数据就可以根据我们的业务需求来转换数据，来实现我们的业务需求逻辑代码。 拿到的数据大概是如下这种： 12345678 // 拿到的数据是如下这种，我们要将它转化成我们请求接口中所需要的数据 console.log(header) // [&quot;手机号&quot;, &quot;姓名&quot;, &quot;入职日期&quot;, &quot;转正日期&quot;, &quot;工号&quot;, ...] console.log(results) // [&#123;入职日期: &#x27;xxx&#x27;, 姓名: &#x27;xxx&#x27;, 工号: &#x27;xxx&#x27;, ...&#125;, &#123;入职日期: &#x27;xxx&#x27;, 姓名: &#x27;xxx&#x27;, 工号: &#x27;xxx&#x27;, ...&#125;] // 我们需要的数据是如下这种 // [&#123;timeOfEntry: &#x27;xxx&#x27;, username: &#x27;xxx&#x27;, workNumber: &#x27;xxx&#x27;, ...&#125;, &#123;timeOfEntry: &#x27;xxx&#x27;, username: &#x27;xxx&#x27;, workNumber: &#x27;xxx&#x27;, ...&#125;]复制代码 下面附上整个代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;template&gt; &lt;upload-excel :on-success=&quot;success&quot; /&gt;&lt;/template&gt; &lt;script&gt;// 导入封装的导入excel表组件import UploadExcel from &#x27;@/components/UploadExcel/index&#x27;import &#123; importEmployee &#125; from &#x27;@/api/employees&#x27;export default &#123; components: &#123; UploadExcel &#125;, data() &#123; &#125;, methods: &#123; // 要使用这个组件，可以传入beforeUpload和onSuccess这两个函数 // beforeUpload要注意要return一个布尔值 // onSuccess这里面可以拿到表格的header(表头)和results(表格内容) // 在我们自己的onSuccess函数里，可以拼接出我们需要的结构的数据 async success(&#123; header, results &#125;) &#123; // 拿到的数据是如下这种，我们要将它转化成我们请求接口中所需要的数据 console.log(header) // [&quot;手机号&quot;, &quot;姓名&quot;, &quot;入职日期&quot;, &quot;转正日期&quot;, &quot;工号&quot;, ...] console.log(results) // [&#123;入职日期: &#x27;xxx&#x27;, 姓名: &#x27;xxx&#x27;, 工号: &#x27;xxx&#x27;, ...&#125;] // 1.定义我们需要的表头的映射关系（表头的字段其实就是我们接口中所需要的参数） const userRelations = &#123; &#x27;入职日期&#x27;: &#x27;timeOfEntry&#x27;, &#x27;手机号&#x27;: &#x27;mobile&#x27;, &#x27;姓名&#x27;: &#x27;username&#x27;, &#x27;转正日期&#x27;: &#x27;correctionTime&#x27;, &#x27;工号&#x27;: &#x27;workNumber&#x27; &#125; // 2.进行数据转换，实现业务需求 var newArr = results.map(item =&gt; &#123; const userInfo = &#123;&#125; Object.keys(item).forEach(k =&gt; &#123; // key是当前的中文名 找到对应的英文名 if (userRelations[k] === &#x27;timeOfEntry&#x27; || userRelations[k] === &#x27;correctionTime&#x27;) &#123; userInfo[userRelations[k]] = new Date(this.formatDate(item[k], &#x27;/&#x27;)) // 只有这样, 才能入库 return &#125; userInfo[userRelations[k]] = item[k] &#125;) return userInfo &#125;) await importEmployee(newArr) this.$message.success(&#x27;导入成功&#x27;) this.$router.back() // 回到上一页 &#125;, formatDate(numb, format) &#123; const time = new Date((numb - 1) * 24 * 3600000 + 1) time.setYear(time.getFullYear() - 70) const year = time.getFullYear() + &#x27;&#x27; const month = time.getMonth() + 1 + &#x27;&#x27; const date = time.getDate() - 1 + &#x27;&#x27; if (format &amp;&amp; format.length === 1) &#123; return year + format + month + format + date &#125; return year + (month &lt; 10 ? &#x27;0&#x27; + month : month) + (date &lt; 10 ? &#x27;0&#x27; + date : date) &#125; &#125;&#125;&lt;/script&gt;复制代码 二、excel的导出1.下载所需js文件Excel 的导入导出都是依赖于js-xlsx来实现的。 在 js-xlsx的基础上又封装了Export2Excel.js来方便导出数据。所以我们可以先下载该js文件到我们的项目目录下（链接地址） src&#x2F;vendor&#x2F;Export2Excel.js 2.安装导出excel所需依赖由于 Export2Excel不仅依赖js-xlsx还依赖file-saver和script-loader，所以我们要再下载两个依赖包。 npm install xlsx file-saver -S npm install script-loader -S -D 3.按需导入引用方法由于下载的Export2Excel.js文件还挺大的，我们可以用按需导入的方法导入到我们的组件中。然后调用导入文件的导出对象上的方法，这个方法需要我们传入一些参数。 123456789101112// 懒加载import(&#x27;@/vendor/Export2Excel&#x27;).then(excel =&gt; &#123; // excel是引入文件（也就是@/ventor/Export2Excel）的导出对象 excel.export_json_to_excel(&#123; header: tHeader, // 表头 必填 [] data, // 具体数据 必填 [[], [], ...] filename: &#x27;excel-list&#x27;, // 导出文件名 非必填 autoWidth: true, // 单元格是否要自适应宽度 非必填 true / false bookType: &#x27;xlsx&#x27; // 导出文件类型 非必填 &#x27;xlsx&#x27;/&#x27;csv&#x27;/&#x27;txt&#x27;等 &#125;)&#125;)复制代码 在导出的函数我们，我们需要将我们项目中拿到的数据转化成参数所需要的数据格式 123456 // 拿到的数据是这种 // [&#123; username: &#x27;xxx&#x27;, mobile: &#x27;xxx&#x27;, ... &#125;, &#123; username: &#x27;xxx&#x27;, mobile: &#x27;xxx&#x27;, ... &#125;] // 要转化的是如下这种 // header: [&#x27;姓名&#x27;, &#x27;手机号&#x27;, &#x27;入职日期&#x27;, ...] // data: [[&#x27;张三&#x27;, &#x27;138xxxxxxxx&#x27;, &#x27;1992-08-04&#x27;, ...], [&#x27;李四&#x27;, &#x27;135xxxxxxxx&#x27;, &#x27;1992-08-04&#x27;, ...]]复制代码 下面附上整个代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 导出数据exportData() &#123; // 1.定义表头对应关系 const headers = &#123; &#x27;姓名&#x27;: &#x27;username&#x27;, &#x27;手机号&#x27;: &#x27;mobile&#x27;, &#x27;入职日期&#x27;: &#x27;timeOfEntry&#x27;, &#x27;聘用形式&#x27;: &#x27;formOfEmployment&#x27;, &#x27;转正日期&#x27;: &#x27;correctionTime&#x27;, &#x27;工号&#x27;: &#x27;workNumber&#x27;, &#x27;部门&#x27;: &#x27;departmentName&#x27; &#125; // 懒加载 import(&#x27;@/vendor/Export2Excel&#x27;).then(async excel =&gt; &#123; // excel是引入文件（也就是@/ventor/Export2Excel）的导出对象 // 获取所有的数据 const &#123; rows &#125; = await getEmployeeList(&#123; page: 1, size: this.page.total &#125;) const data = this.formatJson(headers, rows) // 返回的data就是我们转化后的数据 excel.export_json_to_excel(&#123; // 要求转出的表头是中文 header: Object.keys(headers), // 表头 必填 data, // //具体数据 必填 filename: &#x27;excel-list&#x27;, // 非必填 autoWidth: true, // 非必填 bookType: &#x27;xlsx&#x27; // 非必填 &#125;) // 拿到的数据是这种 // [&#123; username: &#x27;xxx&#x27;, mobile: &#x27;xxx&#x27;, ... &#125;, &#123; username: &#x27;xxx&#x27;, mobile: &#x27;xxx&#x27;, ... &#125;] // 要转化的是如下这种 // header: [&#x27;姓名&#x27;, &#x27;手机号&#x27;, &#x27;入职日期&#x27;, ...] // data: [[&#x27;张三&#x27;, &#x27;138xxxxxxxx&#x27;, &#x27;1992-08-04&#x27;, ...], [&#x27;李四&#x27;, &#x27;135xxxxxxxx&#x27;, &#x27;1992-08-04&#x27;, ...]] &#125;)&#125;,formatJson(headers, rows) &#123; return rows.map(item =&gt; &#123; console.log(item) return Object.keys(headers).map(k =&gt; &#123; if (headers[k] === &#x27;timeOfEntry&#x27; || headers[k] === &#x27;correctionTime&#x27;) &#123; return formatDate(item[headers[k]]) // 返回格式化之前的时间 &#125; else if (headers[k] === &#x27;formOfEmployment&#x27;) &#123; return EmployeeEnum.hireType[item.formOfEmployment] ? EmployeeEnum.hireType[item.formOfEmployment] : &#x27;未知&#x27; &#125; return item[headers[k]] &#125;) &#125;)&#125;复制代码 好啦，以上就是excel表导入导出的步骤啦，有不对的地方欢迎指正哦！~","categories":[],"tags":[]},{"title":"vue3.0笔记","slug":"vue3-0笔记","date":"2022-08-20T10:03:58.000Z","updated":"2022-08-22T01:44:41.293Z","comments":true,"path":"2022/08/20/vue3-0笔记/","link":"","permalink":"http://example.com/2022/08/20/vue3-0%E7%AC%94%E8%AE%B0/","excerpt":"一、创建Vue3.0工程1.使用 vue-cli 创建官方文档：https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create","text":"一、创建Vue3.0工程1.使用 vue-cli 创建官方文档：https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create 123456789## 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上vue --version## 安装或者升级你的@vue/clinpm install -g @vue/cli## 创建vue create vue_test## 启动cd vue_testnpm run serve 2.使用 vite 创建官方文档：https://v3.cn.vuejs.org/guide/installation.html#vite vite官网：https://vitejs.cn 什么是vite？—— 新一代前端构建工具。 优势如下： 开发环境中，无需打包操作，可快速的冷启动。 轻量快速的热重载（HMR）。 真正的按需编译，不再等待整个应用编译完成。 12345678## 创建工程npm init vite-app &lt;project-name&gt;## 进入工程目录cd &lt;project-name&gt;## 安装依赖npm install## 运行npm run dev 二、常用 Composition API官方文档: https://v3.cn.vuejs.org/guide/composition-api-introduction.html 1.拉开序幕的setup 理解：Vue3.0中一个新的配置项，值为一个函数。 setup是所有Composition API（组合API）“ 表演的舞台 ”。 组件中所用到的：数据、方法等等，均要配置在setup中。 setup函数的两种返回值： 若返回一个对象，则对象中的属性、方法, 在模板中均可以直接使用。（重点关注！） 若返回一个渲染函数：则可以自定义渲染内容。（了解） 注意点： 尽量不要与Vue2.x配置混用 Vue2.x配置（data、methos、computed…）中可以访问到setup中的属性、方法。 但在setup中不能访问到Vue2.x配置（data、methos、computed…）。 如果有重名, setup优先。 setup不能是一个async函数，因为返回值不再是return的对象, 而是promise, 模板看不到return对象中的属性。（后期也可以返回一个Promise实例，但需要Suspense和异步组件的配合） 2.ref函数 作用: 定义一个响应式的数据 语法: const xxx = ref(initValue) 创建一个包含响应式数据的引用对象（reference对象，简称ref对象）。 JS中操作数据： xxx.value 模板中读取数据: 不需要.value，直接：&lt;div&gt;&#123;&#123;xxx&#125;&#125;&lt;/div&gt; 备注： 接收的数据可以是：基本类型、也可以是对象类型。 基本类型的数据：响应式依然是靠Object.defineProperty()的get与set完成的。 对象类型的数据：内部 “ 求助 ” 了Vue3.0中的一个新函数—— reactive函数。 3.reactive函数 作用: 定义一个对象类型的响应式数据（基本类型不要用它，要用ref函数） 语法：const 代理对象= reactive(源对象)接收一个对象（或数组），返回一个代理对象（Proxy的实例对象，简称proxy对象） reactive定义的响应式数据是“深层次的”。 内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据进行操作。 4.Vue3.0中的响应式原理vue2.x的响应式 实现原理： 对象类型：通过Object.defineProperty()对属性的读取、修改进行拦截（数据劫持）。 数组类型：通过重写更新数组的一系列方法来实现拦截。（对数组的变更方法进行了包裹）。 1234Object.defineProperty(data, &#x27;count&#x27;, &#123; get () &#123;&#125;, set () &#123;&#125;&#125;) 存在问题： 新增属性、删除属性, 界面不会更新。 直接通过下标修改数组, 界面不会自动更新。 Vue3.0的响应式 实现原理: 通过Proxy（代理）: 拦截对象中任意属性的变化, 包括：属性值的读写、属性的添加、属性的删除等。 通过Reflect（反射）: 对源对象的属性进行操作。 MDN文档中描述的Proxy与Reflect： Proxy：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy Reflect：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect 12345678910111213141516new Proxy(data, &#123; // 拦截读取属性值 get (target, prop) &#123; return Reflect.get(target, prop) &#125;, // 拦截设置属性值或添加新属性 set (target, prop, value) &#123; return Reflect.set(target, prop, value) &#125;, // 拦截删除属性 deleteProperty (target, prop) &#123; return Reflect.deleteProperty(target, prop) &#125;&#125;)proxy.name = &#x27;tom&#x27; 5.reactive对比ref 从定义数据角度对比： ref用来定义：基本类型数据。 reactive用来定义：对象（或数组）类型数据。 备注：ref也可以用来定义对象（或数组）类型数据, 它内部会自动通过reactive转为代理对象。 从原理角度对比： ref通过Object.defineProperty()的get与set来实现响应式（数据劫持）。 reactive通过使用Proxy来实现响应式（数据劫持）, 并通过Reflect操作源对象内部的数据。 从使用角度对比： ref定义的数据：操作数据需要.value，读取数据时模板中直接读取不需要.value。 reactive定义的数据：操作数据与读取数据：均不需要.value。 6.setup的两个注意点 setup执行的时机 在beforeCreate之前执行一次，this是undefined。 setup的参数 props：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性。 context：上下文对象 attrs: 值为对象，包含：组件外部传递过来，但没有在props配置中声明的属性, 相当于 this.$attrs。 slots: 收到的插槽内容, 相当于 this.$slots。 emit: 分发自定义事件的函数, 相当于 this.$emit。 7.计算属性与监视1.computed函数 与Vue2.x中computed配置功能一致 写法 1234567891011121314151617181920import &#123;computed&#125; from &#x27;vue&#x27;setup()&#123; ... //计算属性——简写 let fullName = computed(()=&gt;&#123; return person.firstName + &#x27;-&#x27; + person.lastName &#125;) //计算属性——完整 let fullName = computed(&#123; get()&#123; return person.firstName + &#x27;-&#x27; + person.lastName &#125;, set(value)&#123; const nameArr = value.split(&#x27;-&#x27;) person.firstName = nameArr[0] person.lastName = nameArr[1] &#125; &#125;)&#125; 2.watch函数 与Vue2.x中watch配置功能一致 两个小“坑”： 监视reactive定义的响应式数据时：oldValue无法正确获取、强制开启了深度监视（deep配置失效）。 监视reactive定义的响应式数据中某个属性时：deep配置有效。 1234567891011121314151617181920212223242526272829303132//情况一：监视ref定义的响应式数据watch(sum,(newValue,oldValue)=&gt;&#123; console.log(&#x27;sum变化了&#x27;,newValue,oldValue)&#125;,&#123;immediate:true&#125;)//情况二：监视多个ref定义的响应式数据watch([sum,msg],(newValue,oldValue)=&gt;&#123; console.log(&#x27;sum或msg变化了&#x27;,newValue,oldValue)&#125;) /* 情况三：监视reactive定义的响应式数据 若watch监视的是reactive定义的响应式数据，则无法正确获得oldValue！！ 若watch监视的是reactive定义的响应式数据，则强制开启了深度监视 */watch(person,(newValue,oldValue)=&gt;&#123; console.log(&#x27;person变化了&#x27;,newValue,oldValue)&#125;,&#123;immediate:true,deep:false&#125;) //此处的deep配置不再奏效//情况四：监视reactive定义的响应式数据中的某个属性watch(()=&gt;person.job,(newValue,oldValue)=&gt;&#123; console.log(&#x27;person的job变化了&#x27;,newValue,oldValue)&#125;,&#123;immediate:true,deep:true&#125;) //情况五：监视reactive定义的响应式数据中的某些属性watch([()=&gt;person.job,()=&gt;person.name],(newValue,oldValue)=&gt;&#123; console.log(&#x27;person的job变化了&#x27;,newValue,oldValue)&#125;,&#123;immediate:true,deep:true&#125;)//特殊情况watch(()=&gt;person.job,(newValue,oldValue)=&gt;&#123; console.log(&#x27;person的job变化了&#x27;,newValue,oldValue)&#125;,&#123;deep:true&#125;) //此处由于监视的是reactive素定义的对象中的某个属性，所以deep配置有效 3.watchEffect函数 watch的套路是：既要指明监视的属性，也要指明监视的回调。 watchEffect的套路是：不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性。 watchEffect有点像computed： 但computed注重的计算出来的值（回调函数的返回值），所以必须要写返回值。 而watchEffect更注重的是过程（回调函数的函数体），所以不用写返回值。 123456//watchEffect所指定的回调中用到的数据只要发生变化，则直接重新执行回调。watchEffect(()=&gt;&#123; const x1 = sum.value const x2 = person.age console.log(&#x27;watchEffect配置的回调执行了&#x27;)&#125;) 8.生命周期 Vue3.0中可以继续使用Vue2.x中的生命周期钩子，但有有两个被更名： beforeDestroy改名为 beforeUnmount destroyed改名为 unmounted Vue3.0也提供了 Composition API 形式的生命周期钩子，与Vue2.x中钩子对应关系如下： beforeCreate&#x3D;&#x3D;&#x3D;&gt;setup() created&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;setup() beforeMount &#x3D;&#x3D;&#x3D;&gt;onBeforeMount mounted&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;onMounted beforeUpdate&#x3D;&#x3D;&#x3D;&gt;onBeforeUpdate updated &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;onUpdated beforeUnmount &#x3D;&#x3D;&gt;onBeforeUnmount unmounted &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;onUnmounted 9.自定义hook函数 什么是hook？—— 本质是一个函数，把setup函数中使用的Composition API进行了封装。 类似于vue2.x中的mixin。 自定义hook的优势: 复用代码, 让setup中的逻辑更清楚易懂。 10.toRef 作用：创建一个 ref 对象，其value值指向另一个对象中的某个属性。 语法：const name = toRef(person,&#39;name&#39;) 应用: 要将响应式对象中的某个属性单独提供给外部使用时。 扩展：toRefs 与toRef功能一致，但可以批量创建多个 ref 对象，语法：toRefs(person) 三、其它 Composition API1.shallowReactive 与 shallowRef shallowReactive：只处理对象最外层属性的响应式（浅响应式）。 shallowRef：只处理基本数据类型的响应式, 不进行对象的响应式处理。 什么时候使用? 如果有一个对象数据，结构比较深, 但变化时只是外层属性变化 &#x3D;&#x3D;&#x3D;&gt; shallowReactive。 如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换 &#x3D;&#x3D;&#x3D;&gt; shallowRef。 2.readonly 与 shallowReadonly readonly: 让一个响应式数据变为只读的（深只读）。 shallowReadonly：让一个响应式数据变为只读的（浅只读）。 应用场景: 不希望数据(尤其是这个数据是来自与其他组件时)被修改时。 3.toRaw 与 markRaw toRaw： 作用：将一个由reactive生成的响应式对象转为普通对象。 使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新。 markRaw： 作用：标记一个对象，使其永远不会再成为响应式对象。 应用场景: 有些值不应被设置为响应式的，例如复杂的第三方类库等。 当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能。 4.customRef 作用：创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制。 实现防抖效果： 1234567891011121314151617181920212223242526272829303132333435363738&lt;template&gt; &lt;input type=&quot;text&quot; v-model=&quot;keyword&quot;&gt; &lt;h3&gt;&#123;&#123;keyword&#125;&#125;&lt;/h3&gt;&lt;/template&gt;&lt;script&gt; import &#123;ref,customRef&#125; from &#x27;vue&#x27; export default &#123; name:&#x27;Demo&#x27;, setup()&#123; // let keyword = ref(&#x27;hello&#x27;) //使用Vue准备好的内置ref //自定义一个myRef function myRef(value,delay)&#123; let timer //通过customRef去实现自定义 return customRef((track,trigger)=&gt;&#123; return&#123; get()&#123; track() //告诉Vue这个value值是需要被“追踪”的 return value &#125;, set(newValue)&#123; clearTimeout(timer) timer = setTimeout(()=&gt;&#123; value = newValue trigger() //告诉Vue去更新界面 &#125;,delay) &#125; &#125; &#125;) &#125; let keyword = myRef(&#x27;hello&#x27;,500) //使用程序员自定义的ref return &#123; keyword &#125; &#125; &#125;&lt;/script&gt; 5.provide 与 inject 作用：实现祖与后代组件间通信 套路：父组件有一个 provide 选项来提供数据，后代组件有一个 inject 选项来开始使用这些数据 具体写法： 祖组件中： 123456setup()&#123; ...... let car = reactive(&#123;name:&#x27;奔驰&#x27;,price:&#x27;40万&#x27;&#125;) provide(&#x27;car&#x27;,car) ......&#125; 后代组件中： 123456setup(props,context)&#123; ...... const car = inject(&#x27;car&#x27;) return &#123;car&#125; ......&#125; 6.响应式数据的判断 isRef: 检查一个值是否为一个 ref 对象 isReactive: 检查一个对象是否是由 reactive 创建的响应式代理 isReadonly: 检查一个对象是否是由 readonly 创建的只读代理 isProxy: 检查一个对象是否是由 reactive 或者 readonly 方法创建的代理 四、Composition API 的优势1.Options API 存在的问题使用传统OptionsAPI中，新增或者修改一个需求，就需要分别在data，methods，computed里修改 。 2.Composition API 的优势我们可以更加优雅的组织我们的代码，函数。让相关功能的代码更加有序的组织在一起。 五、新的组件1.Fragment 在Vue2中: 组件必须有一个根标签 在Vue3中: 组件可以没有根标签, 内部会将多个标签包含在一个Fragment虚拟元素中 好处: 减少标签层级, 减小内存占用 2.Teleport 什么是Teleport？—— Teleport 是一种能够将我们的组件html结构移动到指定位置的技术。 12345678&lt;teleport to=&quot;移动位置&quot;&gt; &lt;div v-if=&quot;isShow&quot; class=&quot;mask&quot;&gt; &lt;div class=&quot;dialog&quot;&gt; &lt;h3&gt;我是一个弹窗&lt;/h3&gt; &lt;button @click=&quot;isShow = false&quot;&gt;关闭弹窗&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/teleport&gt; 3.Suspense 等待异步组件时渲染一些额外内容，让应用有更好的用户体验 使用步骤： 异步引入组件 12import &#123;defineAsyncComponent&#125; from &#x27;vue&#x27;const Child = defineAsyncComponent(()=&gt;import(&#x27;./components/Child.vue&#x27;)) 使用Suspense包裹组件，并配置好default 与 fallback 12345678910111213&lt;template&gt; &lt;div class=&quot;app&quot;&gt; &lt;h3&gt;我是App组件&lt;/h3&gt; &lt;Suspense&gt; &lt;template v-slot:default&gt; &lt;Child/&gt; &lt;/template&gt; &lt;template v-slot:fallback&gt; &lt;h3&gt;加载中.....&lt;/h3&gt; &lt;/template&gt; &lt;/Suspense&gt; &lt;/div&gt;&lt;/template&gt; 六、其他1.全局API的转移 Vue 2.x 有许多全局 API 和配置。 例如：注册全局组件、注册全局指令等。 123456789101112//注册全局组件Vue.component(&#x27;MyButton&#x27;, &#123; data: () =&gt; (&#123; count: 0 &#125;), template: &#x27;&lt;button @click=&quot;count++&quot;&gt;Clicked &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&#x27;&#125;)//注册全局指令Vue.directive(&#x27;focus&#x27;, &#123; inserted: el =&gt; el.focus()&#125; Vue3.0中对这些API做出了调整： 将全局的API，即：Vue.xxx调整到应用实例（app）上 2.x 全局 API（Vue） 3.x 实例 API (app) Vue.config.xxxx app.config.xxxx Vue.config.productionTip 移除 Vue.component app.component Vue.directive app.directive Vue.mixin app.mixin Vue.use app.use Vue.prototype app.config.globalProperties 2.其他改变 data选项应始终被声明为一个函数。 过度类名的更改： Vue2.x写法 12345678.v-enter,.v-leave-to &#123; opacity: 0;&#125;.v-leave,.v-enter-to &#123; opacity: 1;&#125; Vue3.x写法 123456789.v-enter-from,.v-leave-to &#123; opacity: 0;&#125;.v-leave-from,.v-enter-to &#123; opacity: 1;&#125; 移除keyCode作为 v-on 的修饰符，同时也不再支持config.keyCodes 移除v-on.native修饰符 父组件中绑定事件 1234&lt;my-component v-on:close=&quot;handleComponentEvent&quot; v-on:click=&quot;handleNativeClickEvent&quot;/&gt; 子组件中声明自定义事件 12345&lt;script&gt; export default &#123; emits: [&#x27;close&#x27;] &#125;&lt;/script&gt; 移除过滤器（filter） 过滤器虽然这看起来很方便，但它需要一个自定义语法，打破大括号内表达式是 “只是 JavaScript” 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器。","categories":[],"tags":[]},{"title":"我的第一篇博客文章","slug":"我的第一篇博客文章","date":"2022-08-20T08:22:20.000Z","updated":"2022-08-20T10:02:18.287Z","comments":true,"path":"2022/08/20/我的第一篇博客文章/","link":"","permalink":"http://example.com/2022/08/20/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/","excerpt":"","text":"内容，我的第一篇博客文章","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2022-08-20T08:18:18.640Z","updated":"2022-08-20T08:18:18.640Z","comments":true,"path":"2022/08/20/hello-world/","link":"","permalink":"http://example.com/2022/08/20/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}