{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"https://chenbin2333.github.io","root":"/"},"pages":[],"posts":[{"title":"","slug":"Object.create和new区别","date":"2022-08-24T09:13:31.427Z","updated":"2022-08-25T05:22:04.435Z","comments":true,"path":"2022/08/24/Object.create和new区别/","link":"","permalink":"https://chenbin2333.github.io/2022/08/24/Object.create%E5%92%8Cnew%E5%8C%BA%E5%88%AB/","excerpt":"","text":"你不知道的javascript之Object.create 和new区别博客原文地址：http://blog.csdn.net/blueblueskyhua/article/details/73135938 前几天有碰到原型的问题。之前以为自己对原型还是有所了解，但是细细研究，发现自己对原型的理解还是太年轻了。 Object.create 和new创建对象的方式，我以我碰到的两种创建方式，Object.create 和new来说明 var Base = function () &#123;&#125; var o1 = new Base(); var o2 = Object.create(Base); 那这样到底有什么不一样呢？ 我先来一段Object.create的实现方式 Object.create = function (o) &#123; var F = function () &#123;&#125;; F.prototype = o; return new F(); &#125;; 可以看出来。Object.create是内部定义一个对象，并且让F.prototype对象 赋值为引进的对象&#x2F;函数 o，并return出一个新的对象。 再看看var o1 &#x3D; new Base()的时候new做了什么。 JavaScript 实际上执行的是： var o1 = new Object(); o1.[[Prototype]] = Base.prototype; Base.call(o1); new做法是新建一个obj对象o1，并且让o1的__proto__指向了Base.prototype对象。并且使用call 进行强转作用环境。从而实现了实例的创建。 我们来看看两个对象打印情况。看似是一样的。 我们对原来的代码进行改进一下。 var Base = function () &#123; this.a = 2 &#125; var o1 = new Base(); var o2 = Object.create(Base); console.log(o1.a); console.log(o2.a); 可以看到Object.create 失去了原来对象的属性的访问。那再看看prototype呢？（一开始没理解prototype和__proto__ 的关系。造成对这两种方式的创建理解非常费解）。再一次对代码进行改进。 var Base = function () &#123; this.a = 2 &#125; Base.prototype.a = 3; var o1 = new Base(); var o2 = Object.create(Base); console.log(o1.a); console.log(o2.a); 我一开始以为输出的值是2,3。。。以为prototype还是存在的。。结果发现真的发错特错。我们看运行的结果。依旧是如此。 那我们就以图说话。 （F在创建后被销毁） 看完上图，我们就知道了，为什么通过Object.create构造的连Base原型上的属性都访问不到，因为他压根就没有指向他的prototype。这也就说明了__proto__ 和 prototype 的区别。所以上面在prototype定义的a，只是Base的prototype对象上的一个属性。 再来看看就是： new关键字必须是以function定义的。 Object.create 则 function和object都可以进行构建。 小结 比较 new Object.create 构造函数 保留原构造函数属性 丢失原构造函数属性 原型链 原构造函数prototype属性 原构造函数&#x2F;（对象）本身 作用对象 function function和object instanceof 和 isPrototypeOf写了创建一个对象实例，并且说了通过原型链来完成这一个个对象之间的联系，但是你怎么知道就一定含有呢？所以我们需要一个判断机制。 function Foo()&#123; //... &#125; Foo.prototype.ff = 2; var a = new Foo(); a instanceof Foo; //true instanceof 说的是在a的整条[[Prototype]] 是否含有Foo.prototype对象。 但是这个方法只能实现对象(a)和函数(带.prototype引用的Foo),如果你想判断两个对象（a 和 b）是否通过[[Prototype]]链关联。只用instanceof就无法实现。 所以这里用到了isPrototypeOf。 var a = &#123;&#125;; var b = Object.ceate(a); b.isPrototypeOf(a);&#x2F;&#x2F;在a的[[Prototype]]是否出现过b来判断。 来看看isPrototypeOf实现方式。 function isRelatedTo(o1,o2)&#123; function F()&#123;&#125; F.prototype = o2; return o1 instanceof F; &#125; 上述函数通过了构建一个辅助函数F，构建了一个prototype对象。从而达到instanceof比较的条件。console.log(a.isPrototypeOf(b) &#x3D;&#x3D;&#x3D; isRelatedTo(b,a));&#x2F;&#x2F; true constructor举例来说，.constructor是在函数声明时候的默认属性。我们先来看看下面的代码。 function Foo()&#123; &#125; console.log(Foo.prototype.constructor === Foo);//true var a = new Foo(); console.log(a.constructor === Foo);//true 看起来a.constructor &#x3D;&#x3D;&#x3D; Foo 为真，意味着a的确有一个.constructor指向Foo的.constructor属性。但是可能出于不理解，或者很多的误操作，都会导致我们.constructor指向的丢失。如下： function Foo()&#123; &#125; Foo.prototype = &#123;&#125; var a1 = new Foo(); console.log(a1.constructor === Foo);//false console.log(a1.constructor === Object);//true 可以看到a1并没有.constructor属性。那是为什么呢。？因为a1没有.constructor属性，他会委托[[prototype]]链上的Foo.prototype。但是新建的Foo.prototype也没有.constructor,所以继续往上找，一直到了顶端的Object.prototype。再来，为了绝对的保证我的代码可靠，不被一些错误操作，影响我们的执行。 function Foo()&#123; &#125; Foo.prototype = &#123;&#125; var a1 = new Foo(); Object.defineProperty(Foo.prototype, &quot;constructor&quot;, &#123; enumerable: false, writeable:true, configureable: true, value: Foo // 让.constructor指向Foo &#125;) 想要说明的就是一点对于.constructor，我们并不能完全信任，稍不留神，一个手误或者不懂原理就去改对象。会发生惨烈的指向错误，所以认为constructor的意思是“由…构造”，这个误解代价太高了。 所以可以看出.constructor是一个非常不可靠，并且不安全的引用。在开发中尽量避免使用这些引用。如果用了，请记得检查你的原型，避免出现.constructor丢失。","categories":[],"tags":[]},{"title":"vue实现excel导入导出","slug":"vue实现excel导入导出","date":"2022-08-20T15:37:36.000Z","updated":"2022-08-22T01:59:47.832Z","comments":true,"path":"2022/08/20/vue实现excel导入导出/","link":"","permalink":"https://chenbin2333.github.io/2022/08/20/vue%E5%AE%9E%E7%8E%B0excel%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/","excerpt":"vue项目的excel的导入与导出 在做人力资源管理的后台项目时，实现了excel表的导入导出功能。用到了vue-element-admin提供的框架链接地址我们只需要在自己的项目中封装改造即可下面，来讲一下在项目中实现excel表的导入与导出的步骤。","text":"vue项目的excel的导入与导出 在做人力资源管理的后台项目时，实现了excel表的导入导出功能。用到了vue-element-admin提供的框架链接地址我们只需要在自己的项目中封装改造即可下面，来讲一下在项目中实现excel表的导入与导出的步骤。 一、excel的导入1.excel导入功能需要使用npm包xlsx，所以需要安装xlsx插件1npm i xlsx 2.将vue-element-admin提供的导入功能新建一个公共组件 ，将组件引入到我们的页面中（为了让我们的项目每次跳转都跳转到一个统一的页面，我们的项目中封装了单独的路由和页面组件@&#x2F;views&#x2F;import&#x2F;index.vue来放excel导入） 注意：这个页面结构用到了element-ui框架，但是如果用的是其他框架只需要改页面结构，逻辑代码是通用的。 @&#x2F;components&#x2F;UploadExcel&#x2F;index.vue 代码到链接中复制即可，要改动的只有页面结构和样式。（代码地址） 3.实现excel的导入在我们的import&#x2F;index.vue组件中，传给UploadExcel&#x2F;index.vue一个onsuccess方法，在这个方法里面我们可以拿到excel表的header表头和results表格数据。拿到这些数据就可以根据我们的业务需求来转换数据，来实现我们的业务需求逻辑代码。 拿到的数据大概是如下这种： 12345678 // 拿到的数据是如下这种，我们要将它转化成我们请求接口中所需要的数据 console.log(header) // [&quot;手机号&quot;, &quot;姓名&quot;, &quot;入职日期&quot;, &quot;转正日期&quot;, &quot;工号&quot;, ...] console.log(results) // [&#123;入职日期: &#x27;xxx&#x27;, 姓名: &#x27;xxx&#x27;, 工号: &#x27;xxx&#x27;, ...&#125;, &#123;入职日期: &#x27;xxx&#x27;, 姓名: &#x27;xxx&#x27;, 工号: &#x27;xxx&#x27;, ...&#125;] // 我们需要的数据是如下这种 // [&#123;timeOfEntry: &#x27;xxx&#x27;, username: &#x27;xxx&#x27;, workNumber: &#x27;xxx&#x27;, ...&#125;, &#123;timeOfEntry: &#x27;xxx&#x27;, username: &#x27;xxx&#x27;, workNumber: &#x27;xxx&#x27;, ...&#125;]复制代码 下面附上整个代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;template&gt; &lt;upload-excel :on-success=&quot;success&quot; /&gt;&lt;/template&gt; &lt;script&gt;// 导入封装的导入excel表组件import UploadExcel from &#x27;@/components/UploadExcel/index&#x27;import &#123; importEmployee &#125; from &#x27;@/api/employees&#x27;export default &#123; components: &#123; UploadExcel &#125;, data() &#123; &#125;, methods: &#123; // 要使用这个组件，可以传入beforeUpload和onSuccess这两个函数 // beforeUpload要注意要return一个布尔值 // onSuccess这里面可以拿到表格的header(表头)和results(表格内容) // 在我们自己的onSuccess函数里，可以拼接出我们需要的结构的数据 async success(&#123; header, results &#125;) &#123; // 拿到的数据是如下这种，我们要将它转化成我们请求接口中所需要的数据 console.log(header) // [&quot;手机号&quot;, &quot;姓名&quot;, &quot;入职日期&quot;, &quot;转正日期&quot;, &quot;工号&quot;, ...] console.log(results) // [&#123;入职日期: &#x27;xxx&#x27;, 姓名: &#x27;xxx&#x27;, 工号: &#x27;xxx&#x27;, ...&#125;] // 1.定义我们需要的表头的映射关系（表头的字段其实就是我们接口中所需要的参数） const userRelations = &#123; &#x27;入职日期&#x27;: &#x27;timeOfEntry&#x27;, &#x27;手机号&#x27;: &#x27;mobile&#x27;, &#x27;姓名&#x27;: &#x27;username&#x27;, &#x27;转正日期&#x27;: &#x27;correctionTime&#x27;, &#x27;工号&#x27;: &#x27;workNumber&#x27; &#125; // 2.进行数据转换，实现业务需求 var newArr = results.map(item =&gt; &#123; const userInfo = &#123;&#125; Object.keys(item).forEach(k =&gt; &#123; // key是当前的中文名 找到对应的英文名 if (userRelations[k] === &#x27;timeOfEntry&#x27; || userRelations[k] === &#x27;correctionTime&#x27;) &#123; userInfo[userRelations[k]] = new Date(this.formatDate(item[k], &#x27;/&#x27;)) // 只有这样, 才能入库 return &#125; userInfo[userRelations[k]] = item[k] &#125;) return userInfo &#125;) await importEmployee(newArr) this.$message.success(&#x27;导入成功&#x27;) this.$router.back() // 回到上一页 &#125;, formatDate(numb, format) &#123; const time = new Date((numb - 1) * 24 * 3600000 + 1) time.setYear(time.getFullYear() - 70) const year = time.getFullYear() + &#x27;&#x27; const month = time.getMonth() + 1 + &#x27;&#x27; const date = time.getDate() - 1 + &#x27;&#x27; if (format &amp;&amp; format.length === 1) &#123; return year + format + month + format + date &#125; return year + (month &lt; 10 ? &#x27;0&#x27; + month : month) + (date &lt; 10 ? &#x27;0&#x27; + date : date) &#125; &#125;&#125;&lt;/script&gt;复制代码 二、excel的导出1.下载所需js文件Excel 的导入导出都是依赖于js-xlsx来实现的。 在 js-xlsx的基础上又封装了Export2Excel.js来方便导出数据。所以我们可以先下载该js文件到我们的项目目录下（链接地址） src&#x2F;vendor&#x2F;Export2Excel.js 2.安装导出excel所需依赖由于 Export2Excel不仅依赖js-xlsx还依赖file-saver和script-loader，所以我们要再下载两个依赖包。 npm install xlsx file-saver -S npm install script-loader -S -D 3.按需导入引用方法由于下载的Export2Excel.js文件还挺大的，我们可以用按需导入的方法导入到我们的组件中。然后调用导入文件的导出对象上的方法，这个方法需要我们传入一些参数。 123456789101112// 懒加载import(&#x27;@/vendor/Export2Excel&#x27;).then(excel =&gt; &#123; // excel是引入文件（也就是@/ventor/Export2Excel）的导出对象 excel.export_json_to_excel(&#123; header: tHeader, // 表头 必填 [] data, // 具体数据 必填 [[], [], ...] filename: &#x27;excel-list&#x27;, // 导出文件名 非必填 autoWidth: true, // 单元格是否要自适应宽度 非必填 true / false bookType: &#x27;xlsx&#x27; // 导出文件类型 非必填 &#x27;xlsx&#x27;/&#x27;csv&#x27;/&#x27;txt&#x27;等 &#125;)&#125;)复制代码 在导出的函数我们，我们需要将我们项目中拿到的数据转化成参数所需要的数据格式 123456 // 拿到的数据是这种 // [&#123; username: &#x27;xxx&#x27;, mobile: &#x27;xxx&#x27;, ... &#125;, &#123; username: &#x27;xxx&#x27;, mobile: &#x27;xxx&#x27;, ... &#125;] // 要转化的是如下这种 // header: [&#x27;姓名&#x27;, &#x27;手机号&#x27;, &#x27;入职日期&#x27;, ...] // data: [[&#x27;张三&#x27;, &#x27;138xxxxxxxx&#x27;, &#x27;1992-08-04&#x27;, ...], [&#x27;李四&#x27;, &#x27;135xxxxxxxx&#x27;, &#x27;1992-08-04&#x27;, ...]]复制代码 下面附上整个代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 导出数据exportData() &#123; // 1.定义表头对应关系 const headers = &#123; &#x27;姓名&#x27;: &#x27;username&#x27;, &#x27;手机号&#x27;: &#x27;mobile&#x27;, &#x27;入职日期&#x27;: &#x27;timeOfEntry&#x27;, &#x27;聘用形式&#x27;: &#x27;formOfEmployment&#x27;, &#x27;转正日期&#x27;: &#x27;correctionTime&#x27;, &#x27;工号&#x27;: &#x27;workNumber&#x27;, &#x27;部门&#x27;: &#x27;departmentName&#x27; &#125; // 懒加载 import(&#x27;@/vendor/Export2Excel&#x27;).then(async excel =&gt; &#123; // excel是引入文件（也就是@/ventor/Export2Excel）的导出对象 // 获取所有的数据 const &#123; rows &#125; = await getEmployeeList(&#123; page: 1, size: this.page.total &#125;) const data = this.formatJson(headers, rows) // 返回的data就是我们转化后的数据 excel.export_json_to_excel(&#123; // 要求转出的表头是中文 header: Object.keys(headers), // 表头 必填 data, // //具体数据 必填 filename: &#x27;excel-list&#x27;, // 非必填 autoWidth: true, // 非必填 bookType: &#x27;xlsx&#x27; // 非必填 &#125;) // 拿到的数据是这种 // [&#123; username: &#x27;xxx&#x27;, mobile: &#x27;xxx&#x27;, ... &#125;, &#123; username: &#x27;xxx&#x27;, mobile: &#x27;xxx&#x27;, ... &#125;] // 要转化的是如下这种 // header: [&#x27;姓名&#x27;, &#x27;手机号&#x27;, &#x27;入职日期&#x27;, ...] // data: [[&#x27;张三&#x27;, &#x27;138xxxxxxxx&#x27;, &#x27;1992-08-04&#x27;, ...], [&#x27;李四&#x27;, &#x27;135xxxxxxxx&#x27;, &#x27;1992-08-04&#x27;, ...]] &#125;)&#125;,formatJson(headers, rows) &#123; return rows.map(item =&gt; &#123; console.log(item) return Object.keys(headers).map(k =&gt; &#123; if (headers[k] === &#x27;timeOfEntry&#x27; || headers[k] === &#x27;correctionTime&#x27;) &#123; return formatDate(item[headers[k]]) // 返回格式化之前的时间 &#125; else if (headers[k] === &#x27;formOfEmployment&#x27;) &#123; return EmployeeEnum.hireType[item.formOfEmployment] ? EmployeeEnum.hireType[item.formOfEmployment] : &#x27;未知&#x27; &#125; return item[headers[k]] &#125;) &#125;)&#125;复制代码 好啦，以上就是excel表导入导出的步骤啦，有不对的地方欢迎指正哦！~","categories":[],"tags":[]},{"title":"vue3.0笔记","slug":"vue3-0笔记","date":"2022-08-20T10:03:58.000Z","updated":"2022-08-24T08:05:45.079Z","comments":true,"path":"2022/08/20/vue3-0笔记/","link":"","permalink":"https://chenbin2333.github.io/2022/08/20/vue3-0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"初学vue3说来惭愧，vue3都发布了一年左右了，我才来学习vue3，看来我是真的弱鸡，现在的我是站在巨人的肩膀上来学习，刚出来vue3全是英文，看都看不懂，现在起码有中文了，结合了许多大佬的见解写出来的小白通俗易懂vue3理解，写的不好希望大家轻喷 ok，ok同志们，没有什么花里胡哨的开场白，今天我们来了解下vue3. 了解vue3创建方式首先我们先创建vue3文件，当然这一步和vue2一样，我就不一一描述了哈，懂的都懂。 都创建好了吧，创建好了我们就来讲一讲vite😝 第一我们要先了解vite是什么，vite是尤雨溪团队开发的新一代的前端构建工具，意图取代webpack，首先我们先来看一看vite有什么优点 无需打包，快速的冷服务器启动 即时热模块更换（HMR，热更新） 真正的按需编译 webpack是一开始是入口文件，然后分析路由，然后模块，最后进行打包，然后告诉你，服务器准备好了（默认8080） 然而vite是什么，它一开始是先告诉你服务器准备完成，然后等你发送HTTP请求，然后是入口文件，Dynamic import（动态导入）code split point（代码分割）如何使用vite呢，大家可以去看官网，也可以看我写的 1234567//要构建一个 Vite + Vue 项目，运行，使用 NPM:npm init @vitejs/app 项目名//使用 Yarn:yarn create @vitejs/app 项目名你会觉得非常快速的创建了项目，然而它并没有给你下载依赖，你还有进入文件然后npm install (or yarn)复制代码 然后它的打开方式不是 serve 变成了dev Edit components/HelloWorld.vue to test hot module replacement. 编辑components&#x2F;HelloWorld.vue以测试热模块更换。（也就是热更新更快） 然而我们只是简单了解下，我们现在的重点是vue3，如果以后vite成为主流，我们也可以在回头看看。😜 现在还是以主流的方式创建并进行讲解 分析vue3基本了解当我们创建完成vue3项目后，点击它的main.js，你会发现写法发生了改变 引入的不是vue构造函数，而是createApp工厂函数然而，创建实例对象其实就相当于vue2中的vm，mount（&#39;#app&#39;）就相当于$mount(&#39;#app&#39;)，并且vue2的写法在vue3不能兼容 现在我们进入App组件，你会发现什么不一样的地方，他没有了根标签，在vue2的时候，我们都是在div根标签里面写东西，所以在vue3里面可以没有根标签 常用组合式API（重点！！！）setupsetup函数是 Composition API（组合API）的入口 在setup函数中定义的变量和方法最后都是需要 return 出去的 不然无法再模板中使用 123456789101112131415161718192021&lt;script&gt; export default &#123; name: &#x27;App&#x27;, setup()&#123; let name = &#x27;流星&#x27; let age = 18 //方法 function say()&#123; console.log(`我叫$&#123;name&#125;,今年$&#123;age&#125;岁`) &#125; //返回一个对象 return &#123; name, age, say &#125; &#125; &#125;&lt;/script&gt;复制代码 当然这不是响应式的写法，然后你们可能会问，为什么没有用this，我们要想一想之前为什么要用this，还不是作用域的问题，然而这次我们都在setup里面，所以不会用到this，而且这里兼容vue2的写法如：data，methods...，并且在vue2中可以读取到vue3里的配置但是vue3里面不能读取到vue2的配置，所以，vue3和vue2不要混用，如果有重名那么优先setup。 ps.如果大家不喜欢return这样的写法的话，可以用vue3新语法糖&lt;script setup&gt;， &lt;script setup&gt;就相当于在编译运行是把代码放到了 setup 函数中运行，然后把导出的变量定义到上下文中，并包含在返回的对象中。具体操作可以看掘金其他大佬 script setup基本使用 上手后才知道 ，Vue3 的 script setup 语法糖是真的爽 vue3新语法糖——setup script …… setup还有几个注意点 它比beforeCreate和created这两个生命周期还要快，就是说，setup在beforeCreate,created前，它里面的this打印出来是undefined setup可以接受两个参数，第一个参数是props,也就是组件传值，第二个参数是context,上下文对象，context里面还有三个很重要的东西attrs，slots,emit，它们就相当于vue2里面的this.$attrs,this.$slots,this.$emit。 通过打印，你可以看到传值，但是会有警告，那是因为我传了两个值，却只接收了一个，要是两个都接收就不会出现警告了 这个是因为vue3中要求我们用emits去接收，接收后就不会警告了，但是也可以不理警告直接用 使用插槽时，不能使用 slot=&quot;XXX&quot;,要使用v-slot，不然会报错 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859父&lt;template&gt; &lt;div class=&quot;home&quot;&gt; &lt;HelloWorld wish=&quot;不掉发&quot; wishes=&quot;变瘦&quot; @carried=&quot;carried&quot;&gt; &lt;h3&gt;实现插槽1&lt;/h3&gt; &lt;template v-slot:dome&gt; &lt;h4&gt;实现插槽2&lt;/h4&gt; &lt;/template&gt; &lt;/HelloWorld&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import HelloWorld from &quot;./components/HelloWorld&quot;;export default &#123; name: &#x27;Home&#x27;, components:&#123; HelloWorld &#125;, setup()&#123; function carried(value)&#123; alert(`牛呀，都实现了！！！$&#123;value&#125;`) &#125; return &#123; carried &#125; &#125;&#125;&lt;/script&gt;-------子&lt;template&gt; &lt;h1&gt;HelloWorld&lt;/h1&gt; &lt;h1&gt;&#123;&#123; wish &#125;&#125;&lt;/h1&gt; &lt;button @click=&quot;dream&quot;&gt;点击实现&lt;/button&gt; &lt;slot&gt;&lt;/slot&gt; &lt;slot name=&quot;dome&quot;&gt;&lt;/slot&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;HelloWorld&quot;, props: [&quot;wish&quot;,&#x27;wishes&#x27;], emits:[&#x27;carried&#x27;], setup(props,context) &#123; console.log(props) console.log(context.attrs) function dream()&#123; context.emit(&#x27;carried&#x27;,666) &#125; return&#123; dream &#125; &#125;,&#125;;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;复制代码 ref与reactiveref上方我说到，我们写的不是响应式数据，我们写的只是字符串和数字，那怎么变成响应式数据呢，那就呀引入ref，但是如果我们直接在代码里面修改是修改不了的,不如打印一下name和age，你会发现ref把它们变成了对象 并且还是RefImpl的实例对象 12345678910111213141516171819202122232425262728293031&lt;template&gt; &lt;div class=&quot;home&quot;&gt; &lt;h1&gt;姓名：&#123;&#123;name&#125;&#125;&lt;/h1&gt; &lt;h1&gt;年龄：&#123;&#123;age&#125;&#125;&lt;/h1&gt; &lt;button @click=&quot;say&quot;&gt;修改&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123;ref&#125; from &#x27;vue&#x27;export default &#123; name: &#x27;Home&#x27;, setup()&#123; let name = ref(&#x27;燕儿&#x27;) let age = ref(18) console.log(name) console.log(age) //方法 function say()&#123; name=&#x27;苒苒&#x27; age=20 &#125; return &#123; name, age, say &#125; &#125;&#125;&lt;/script&gt;复制代码 所以，在修改的时候要.value去修改，里面还是走的get与set去修改页面其实按道理的话，我们在页面上用的话应该要&#123;&#123;name.value&#125;&#125;显示的，但是因为vue3检测到你是ref对象，它就自动给你.value了 12345function say()&#123; name.value=&#x27;苒苒&#x27; age.value=20&#125;复制代码 那么要是我定义的ref是个对象呢，因为我们知道尽管ref后会变成RefImpl的实例对象，所以我们就用XX.value.xx进行修改 12345678910111213141516171819202122232425262728293031323334353637&lt;template&gt; &lt;div class=&quot;home&quot;&gt; &lt;h1&gt;姓名：&#123;&#123;name&#125;&#125;&lt;/h1&gt; &lt;h1&gt;年龄：&#123;&#123;age&#125;&#125;&lt;/h1&gt; &lt;h2&gt;职业：&#123;&#123;job.occupation&#125;&#125;&lt;/h2&gt; &lt;h2&gt;薪资：&#123;&#123;job.salary&#125;&#125;&lt;/h2&gt; &lt;button @click=&quot;say&quot;&gt;修改&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123;ref&#125; from &#x27;vue&#x27;export default &#123; name: &#x27;Home&#x27;, setup()&#123; let name = ref(&#x27;燕儿&#x27;) let age = ref(18) let job=ref(&#123; occupation:&#x27;程序员&#x27;, salary:&#x27;10k&#x27; &#125;) console.log(name) console.log(age) //方法 function say()&#123; job.value.salary=&#x27;12k&#x27; &#125; return &#123; name, age, job, say &#125; &#125;&#125;&lt;/script&gt;复制代码 但是我们打印job.value,你会发现，它不再是RefImpl实例对象，变成了Proxy实例对象，他只是vue3底层，把对象都变成了Proxy实例对象，对于基本数据类型就是按照Object.defineProperty里面的get和set进行数据劫持然后进行响应式，但是如果是对象类型的话，是用到的Proxy，但是vue3把它封装在新函数reactive里，就相当于，ref中是对象，自动会调用reactive。 reactivereactive只能定义对象类型的响应式数据，前面说到的ref里是对象的话，会自动调用reactive，把Object转换为Proxy，那我们来打印一下，你会发现就直接变成了Proxy，之前为什么会.value呢，是因为要去获取值，然后通过reactive变成Proxy，但是现在是直接通过reactive变成Proxy，而且它是进行的一个深层次的响应式，也可以进行数组的响应式 12345678910111213141516171819202122232425262728293031323334353637383940&lt;template&gt; &lt;div class=&quot;home&quot;&gt; &lt;h1&gt;姓名：&#123;&#123;name&#125;&#125;&lt;/h1&gt; &lt;h1&gt;年龄：&#123;&#123;age&#125;&#125;&lt;/h1&gt; &lt;h2&gt;职业：&#123;&#123;job.occupation&#125;&#125;&lt;br&gt;薪资：&#123;&#123;job.salary&#125;&#125;&lt;/h2&gt; &lt;h3&gt;爱好：&#123;&#123;hobby[0]&#125;&#125;,&#123;&#123;hobby[1]&#125;&#125;,&#123;&#123; hobby[2] &#125;&#125;&lt;/h3&gt; &lt;button @click=&quot;say&quot;&gt;修改&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123;ref,reactive&#125; from &#x27;vue&#x27;export default &#123; name: &#x27;Home&#x27;, setup()&#123; let name = ref(&#x27;燕儿&#x27;) let age = ref(18) let job=reactive(&#123; occupation:&#x27;程序员&#x27;, salary:&#x27;10k&#x27; &#125;) let hobby=reactive([&#x27;刷剧&#x27;,&#x27;吃鸡&#x27;,&#x27;睡觉&#x27;]) console.log(name) console.log(age) //方法 function say()&#123; job.salary=&#x27;12k&#x27; hobby[0]=&#x27;学习&#x27; &#125; return &#123; name, age, job, say, hobby &#125; &#125;&#125;&lt;/script&gt;复制代码 有些人可能觉得，哎呀，我记不住，我就用ref，每次就.value可以了，香香香。他喵的，你正常点，要是一个页面就几个数据的话那还好，要是一堆数据，不得把你.value点的冒烟吗？，其实你可以按照之前vue2中data的形式来写，这样你就会觉得reactive香的一批了😁 12345678910111213141516171819202122232425262728293031323334353637&lt;template&gt; &lt;div class=&quot;home&quot;&gt; &lt;h1&gt;姓名：&#123;&#123;data.name&#125;&#125;&lt;/h1&gt; &lt;h1&gt;年龄：&#123;&#123;data.age&#125;&#125;&lt;/h1&gt; &lt;h2&gt;职业：&#123;&#123;data.job.occupation&#125;&#125;&lt;br&gt;薪资：&#123;&#123;data.job.salary&#125;&#125;&lt;/h2&gt; &lt;h3&gt;爱好：&#123;&#123;data.hobby[0]&#125;&#125;,&#123;&#123;data.hobby[1]&#125;&#125;,&#123;&#123; data.hobby[2] &#125;&#125;&lt;/h3&gt; &lt;button @click=&quot;say&quot;&gt;修改&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123;reactive&#125; from &#x27;vue&#x27;export default &#123; name: &#x27;Home&#x27;, setup()&#123; let data=reactive(&#123; name:&#x27;燕儿&#x27;, age:18, job:&#123; occupation:&#x27;程序员&#x27;, salary:&#x27;10k&#x27; &#125;, hobby:[&#x27;刷剧&#x27;,&#x27;吃鸡&#x27;,&#x27;睡觉&#x27;] &#125;) //方法 function say()&#123; data.job.salary=&#x27;12k&#x27; data.hobby[0]=&#x27;学习&#x27; &#125; return &#123; data, say, &#125; &#125;&#125;&lt;/script&gt;复制代码 怎么样，是不是直接暴露出去个data就好了，这样起码更能理解，不会让人摸不着头脑为什么要.value，是吧😊 ref与reactive的区别 ref用来定义：基本类型数据。 ref通过Object.defineProperty()的get与set来实现响应式（数据劫持）。 ref定义的数据：操作数据需要.value，读取数据时模板中直接读取不需要.value。 reactive用来定义：对象或数组类型数据。 reactive通过使用Proxy来实现响应式（数据劫持）, 并通过Reflect操作源代码内部的数据。 reactive定义的数据：操作数据与读取数据：均不需要.value。 当然，我之前就说过，ref可以定义对象或数组的，它只是内部自动调用了reactive来转换。 vue3的响应式原理说到vue3的响应式原理，那我们就不得不提一句vue2的响应式了，（狗都知道的一句）通过Object.defineProperty的get，set来进行数据劫持，修改，从而响应式,但是它有什么缺点呢😶 由于只有get()、set() 方式，所以只能捕获到属性读取和修改操作，当 新增、删除属性时，捕获不到，导致界面也不会更新。 直接通过下标修改数组，界面也不会自动更新。 ok，vue2就聊这么多，什么？你还想听vue2底层？那你就Alt+←，拜拜了您嘞。 对于vue3中的响应式，我们用到的Proxy，当然，我们在vue2里面知道，Proxy是什么，是代理，当然，并不是只用到了它，还有个Window上的内置对象Reflect（反射） 通过Proxy（代理）: 拦截对象中任意属性的变化, 包括：属性值的读写、属性的添加、属性的删除等。 通过Reflect（反射）: 对源对象的属性进行操作。 123456789101112131415const p=new Proxy(data, &#123;// 读取属性时调用 get (target, propName) &#123; return Reflect.get(target, propName) &#125;,//修改属性或添加属性时调用 set (target, propName, value) &#123; return Reflect.set(target, propName, value) &#125;,//删除属性时调用 deleteProperty (target, propName) &#123; return Reflect.deleteProperty(target, propName) &#125;&#125;) 复制代码 computed，watch与watchEffectcomputed在vue3中，把computed变成为组合式API，那么就意味着你要去引入它，代码如下，一个简易的计算就完成了 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;div class=&quot;home&quot;&gt; 姓：&lt;input type=&quot;text&quot; v-model=&quot;names.familyName&quot;&gt;&lt;br&gt; 名：&lt;input type=&quot;text&quot; v-model=&quot;names.lastName&quot;&gt;&lt;br&gt; 姓名：&#123;&#123;fullName&#125;&#125;&lt;br&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123;reactive,computed&#125; from &#x27;vue&#x27;export default &#123; name: &#x27;Home&#x27;, setup()&#123; let names=reactive(&#123; familyName:&#x27;阿&#x27;, lastName:&#x27;斌&#x27; &#125;) fullName=computed(()=&gt;&#123; return names.familyName+&#x27;.&#x27;+names.lastName &#125;) return &#123; names, fullName &#125; &#125;&#125;&lt;/script&gt;复制代码 要是你去修改计算出来的东西，你知道会发生什么吗？警告的意思是计算出来的东西是一个只读属性。 那要是我们想要修改怎么办呢,那么就要用到computed的终结写法了 12345678910111213141516171819202122232425262728293031323334&lt;template&gt; &lt;div class=&quot;home&quot;&gt; 姓：&lt;input type=&quot;text&quot; v-model=&quot;names.familyName&quot;&gt;&lt;br&gt; 名：&lt;input type=&quot;text&quot; v-model=&quot;names.lastName&quot;&gt;&lt;br&gt; 姓名：&lt;input type=&quot;text&quot; v-model=&quot;names.fullName&quot;&gt;&lt;br&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123;reactive,computed&#125; from &#x27;vue&#x27;export default &#123; name: &#x27;Home&#x27;, setup()&#123; let names=reactive(&#123; familyName:&#x27;阿&#x27;, lastName:&#x27;斌&#x27; &#125;) names.fullName=computed(&#123; get()&#123; return names.familyName+&#x27;.&#x27;+names.lastName &#125;, set(value)&#123; let nameList=value.split(&#x27;.&#x27;) names.familyName=nameList[0] names.lastName=nameList[1] &#125; &#125;) return &#123; names &#125; &#125;&#125;&lt;/script&gt;复制代码 但是，yysy（有一说一），他喵的，我寻思也没有人会去改计算属性吧？如果有，就当我没说😷 watch你可能会想到computed都是组合式API，那么watch会不会也是组合式API呢？大胆点，它也是， 那么我们就来进行监视 1234567891011121314151617181920212223&lt;template&gt; &lt;div class=&quot;home&quot;&gt; &lt;h1&gt;当前数字为:&#123;&#123;num&#125;&#125;&lt;/h1&gt; &lt;button @click=&quot;num++&quot;&gt;点击数字加一&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123;ref,watch&#125; from &#x27;vue&#x27;export default &#123; name: &#x27;Home&#x27;, setup()&#123; let num=ref(&#x27;0&#x27;) watch(num,(newValue,oldValue)=&gt;&#123; console.log(`当前数字增加了,$&#123;newValue&#125;,$&#123;oldValue&#125;`) &#125;) return &#123; num &#125; &#125;&#125;&lt;/script&gt;复制代码 当然这是监听ref定义出来的单个响应式数据，要是监听多个数据应该怎么办呢？其实可以用多个watch去进行监听，当然这不是最好的方法，最好的办法其实是监视数组 1234 watch([num,msg],(newValue,oldValue)=&gt;&#123; console.log(&#x27;当前改变了&#x27;,newValue,oldValue) &#125;)复制代码 既然我们监听的是数组，那么我们得到的newValue和oldValue也就是数组，那么数组中的第一个就是你监视的第一个参数。 ps.当然之前在vue2中watch不是有什么其他参数吗，vue3中也有,是写在最后的。 1234watch([num,msg],(newValue,oldValue)=&gt;&#123; console.log(&#x27;当前改变了&#x27;,newValue,oldValue) &#125;,&#123;immediate:true,deep:true&#125;)复制代码 之前我说过，我们现在监听的是监听ref定义出来数据，那么要是我们监听的是reactive 123456789101112131415161718192021222324252627282930313233&lt;template&gt; &lt;div class=&quot;home&quot;&gt; &lt;h1&gt;当前姓名:&#123;&#123;names.familyName&#125;&#125;&lt;/h1&gt; &lt;h1&gt;当前年龄:&#123;&#123;names.age&#125;&#125;&lt;/h1&gt; &lt;h1&gt;当前薪水:&#123;&#123;names.job.salary&#125;&#125;K&lt;/h1&gt; &lt;button @click=&quot;names.familyName+=&#x27;!&#x27;&quot;&gt;点击加!&lt;/button&gt; &lt;button @click=&quot;names.age++&quot;&gt;点击加一&lt;/button&gt; &lt;button @click=&quot;names.job.salary++&quot;&gt;点击薪水加一&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123;reactive,watch&#125; from &#x27;vue&#x27;export default &#123; name: &#x27;Home&#x27;, setup()&#123; let names=reactive(&#123; familyName: &#x27;鳌&#x27;, age:23, job:&#123; salary:10 &#125; &#125;) watch(names,(newValue,oldValue)=&gt;&#123; console.log(`names改变了`,newValue,oldValue) &#125;,&#123;deep:false&#125;) return &#123; names &#125; &#125;&#125;&lt;/script&gt;复制代码 但是你会发现一个问题，为什么newValue与oldValue一样呢，就很尴尬，都是新的数据，就算你使用ref来定义，还是没有办法监听到oldValue（他喵的，都给你说了ref定义的对象会自动调用reactive）,所以在监视reactive定义的响应式数据时，oldValue无法正确获取,并且你会发现，它是强制开启深度监视（deep:true），并且无法关闭。 然而现在我们监视的是reactive定义的响应式数据的全部属性，是只监听其中的一个属性，那怎么办呢，可能大家会 1234watch(names.age,(newValue,oldValue)=&gt;&#123; console.log(`names改变了`,newValue,oldValue)&#125;)复制代码 来进行监视，但是，vue3会警告只能监听reactive定义的或者ref定义的,并且不能监听。那么我们就必须这样写（不会还有人不知道return可以省略吧？不会吧？不会吧？不会那个人就是你吧？） 1234watch(()=&gt;names.age,(newValue,oldValue)=&gt;&#123; console.log(&#x27;names改变了&#x27;,newValue,oldValue)&#125;)复制代码 那么要是我们监听的是多个属性，那怎么办呢？emmmm，你正常点，我上面都写了监听多个ref定义的响应式数据，你就不会举一反三吗？敲代码很累的好吧！！！他喵的，为了防止你们问多个reactive定义的一个属性，我就只能说和这个是一样的！！！能不能聪明点！！！ 1234watch([()=&gt;names.age,()=&gt;names.familyName],(newValue,oldValue)=&gt;&#123; console.log(&#x27;names改变了&#x27;,newValue,oldValue)&#125;)复制代码 ok，要是我们监听的是深度的属性那要怎么办呢？你会发现我要是只监听第一层是监听不到的，那么我们有两种写法 123456789//第一种watch(()=&gt; names.job.salary,(newValue,oldValue)=&gt;&#123; console.log(&#x27;names改变了&#x27;,newValue,oldValue)&#125;)//第二种watch(()=&gt; names.job,(newValue,oldValue)=&gt;&#123; console.log(&#x27;names改变了&#x27;,newValue,oldValue)&#125;,&#123;deep:true&#125;)复制代码 那么我们就可以这样理解，如果监视的是reactive定义的响应式数据的属性，并且这个属性是对象，那么我们可以开启深度监视 （人都写傻了，写了四千多字了，还没写完…） watchEffectwatchEffect是vue3的新函数，它是来和watch来抢饭碗的，它和watch是一样的功能，那它有什么优势呢？ 自动默认开启了immediate:true 用到了谁就监视谁 123456watchEffect(()=&gt;&#123; const one = num.value const tow = person.age console.log(&#x27;watchEffect执行了&#x27;)&#125;)复制代码 其实吧，watchEffect有点像computed，都是里面的值发生了改变就调用一次，但是呢computed要写返回值,而watchEffect不用写返回值。 生命周期 我们先来简单分析下，在vue2中，我们是先new Vue()，然后执行beforeCreate与created接着问你有没有vm.$mount(el)，有，才继续执行，但是在vue3中，它是先全部准备好后然后再进行函数。 其实在vue3中生命周期没有多大的改变，只是改变了改变了销毁前，和销毁，让它更加语义化了 beforeDestroy改名为beforeUnmount,destroyed改名为unmounted 然后在vue3中，**beforeCreate与created并没有组合式API中,setup就相当于这两个生命周期函数** 在vue3中也可以按照之前的生命周期函数那样写，只是要记得有些函数名称发生了改变 在setup里面应该这样写 beforeCreate&#x3D;&#x3D;&#x3D;&gt;Not needed* created&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;Not needed* beforeMount &#x3D;&#x3D;&#x3D;&gt;onBeforeMount mounted&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;onMounted beforeUpdate&#x3D;&#x3D;&#x3D;&gt;onBeforeUpdate updated &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;onUpdated beforeUnmount &#x3D;&#x3D;&gt;onBeforeUnmount unmounted &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;onUnmounted hooks函数 Vue3 的 hook函数 相当于 vue2 的 mixin, 不同在与 hooks 是函数 Vue3 的 hook函数 可以帮助我们提高代码的复用性, 让我们能在不同的组件中都利用 hooks 函数 其实就是代码的复用，可以用到外部的数据，生命钩子函数…，具体怎么用直接看代码， 12345678910111213141516171819202122232425262728293031//一般都是建一个hooks文件夹，都写在里面import &#123;reactive,onMounted,onBeforeUnmount&#125; from &#x27;vue&#x27;export default function ()&#123; //鼠标点击坐标 let point = reactive(&#123; x:0, y:0 &#125;) //实现鼠标点击获取坐标的方法 function savePoint(event)&#123; point.x = event.pageX point.y = event.pageY console.log(event.pageX,event.pageY) &#125; //实现鼠标点击获取坐标的方法的生命周期钩子 onMounted(()=&gt;&#123; window.addEventListener(&#x27;click&#x27;,savePoint) &#125;) onBeforeUnmount(()=&gt;&#123; window.removeEventListener(&#x27;click&#x27;,savePoint) &#125;) return point&#125;//在其他地方调用import useMousePosition from &#x27;./hooks/useMousePosition&#x27;let point = useMousePosition（）复制代码 toRef与toRefstoReftoRef翻译过来其实就是把什么变成ref类型的数据，可能大家会觉得没有什么用，毕竟我们之前定义时就已经定义成ref,但是你们想一想，我们在之前是怎么写的 123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;div class=&quot;home&quot;&gt; &lt;h1&gt;当前姓名:&#123;&#123;names.name&#125;&#125;&lt;/h1&gt; &lt;h1&gt;当前年龄:&#123;&#123;names.age&#125;&#125;&lt;/h1&gt; &lt;h1&gt;当前薪水:&#123;&#123;names.job.salary&#125;&#125;K&lt;/h1&gt; &lt;button @click=&quot;names.name+=&#x27;!&#x27;&quot;&gt;点击加!&lt;/button&gt; &lt;button @click=&quot;names.age++&quot;&gt;点击加一&lt;/button&gt; &lt;button @click=&quot;names.job.salary++&quot;&gt;点击薪水加一&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123;reactive&#125; from &#x27;vue&#x27;export default &#123; name: &#x27;Home&#x27;, setup()&#123; let names=reactive(&#123; name:&#x27;老谭&#x27;, age:23, job:&#123; salary:10 &#125; &#125;) return &#123; names &#125; &#125;&#125;&lt;/script&gt;复制代码 是不是一直都是用到代码name.xx，可能你会说，那我就return的时候不这样写，改成这样 123456return &#123; name:names.name, age:names.age, salary:names.job.salary&#125;复制代码 但是你要是在页面进行操作时就不是响应式了，为什么呢？那是因为你现在暴露出去的是简简单单的字符串，字符串会有响应式吗？肯定没有呀，但是你要是用到了toRef,那就是把name.xx变为响应式，然后操作它时会自动的去修改name里面的数据 123456return &#123; name:toRef(names,&#x27;name&#x27;), age:toRef(names,&#x27;age&#x27;), salary:toRef(names.job,&#x27;salary&#x27;)&#125;复制代码 但是有的人可能会说那我为什么不用ref去改变？可能大家会发现在页面里也是响应式的，但是我告诉你们，根本用到的不是names里面的数据，而是你单独定义出来的数据，所以要是这样写，无论怎么修改都不会修改到names里的数据 123456return &#123; name:ref(names.name), age:ref(names.age), salary:ref(names.job.salary),&#125;复制代码 toRefs聪明一点，toRefs与toRef有什么不同，加了个s,toRef是单个转化为响应式，那toRefs就是多个转化为响应式咯，这样的话就减少代码，不然要是有成千上万个，那你不是要当憨憨闷写吗？（...是结构哈,看不懂就麻溜的alt+←)，当然它只会结构一层，深层里的代码还是要老实的写 123456 &lt;h1&gt;当前姓名:&#123;&#123;name&#125;&#125;&lt;/h1&gt; &lt;h1&gt;当前薪水:&#123;&#123;job.salary&#125;&#125;K&lt;/h1&gt;return &#123; ...toRefs(names)&#125;复制代码 其他组合式API（了解，我寻思你基本上不会用）shallowReactive 与 shallowRefshallowReactive浅层次的响应式,它就是只把第一层的数据变为响应式，深层的数据不会变为响应式,shallowRef如果定义的是基本类型的数据，那么它和ref是一样的不会有什么改变，但是要是定义的是对象类型的数据，那么它就不会进行响应式，之前我们说过如果ref定义的是对象，那么它会自动调用reactive变为Proxy,但是要是用到的是shallowRef那么就不会调用reactive去进行响应式。 shallowReactive：只处理对象最外层属性的响应式（浅响应式）。 shallowRef：只处理基本数据类型的响应式, 不进行对象的响应式处理。 1234567891011let person = shallowReactive(&#123; name:&#x27;大理段氏&#x27;, age:10, job:&#123; salary:20 &#125;&#125;)let x = shallowRef(&#123; y:0&#125;)复制代码 readonly 与 shallowReadonlyreadonly是接收了一个响应式数据然后重新赋值，返回的数据就不允许修改（深层只读），shallowReadonly却只是浅层只读（第一层只读，其余层可以进行修改） 123names=readonly(names)names=shallowReadonly(names)复制代码 toRaw 与 markRawtoRaw其实就是将一个由reactive生成的响应式对象转为普通对象。如果是ref定义的话，是没有效果的（包括ref定义的对象）如果在后续操作中对数据进行了添加的话，添加的数据为响应式数据，当然要是将数据进行markRaw操作后就不会变为响应式，可能大家会说，不就是和readonly一样吗？那肯定不一样咯，readonly是根本没办法改，但markRaw是不转化为响应式，但是数据还会发生改变。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;template&gt; &lt;div class=&quot;home&quot;&gt; &lt;h1&gt;当前姓名:&#123;&#123;names.name&#125;&#125;&lt;/h1&gt; &lt;h1&gt;当前年龄:&#123;&#123;names.age&#125;&#125;&lt;/h1&gt; &lt;h1&gt;当前薪水:&#123;&#123;names.job.salary&#125;&#125;K&lt;/h1&gt; &lt;h1 v-if=&quot;names.girlFriend&quot;&gt;女朋友：&#123;&#123;names.girlFriend&#125;&#125;&lt;/h1&gt; &lt;button @click=&quot;names.name+=&#x27;!&#x27;&quot;&gt;点击加!&lt;/button&gt; &lt;button @click=&quot;addAges&quot;&gt;点击加一&lt;/button&gt; &lt;button @click=&quot;addSalary&quot;&gt;点击薪水加一&lt;/button&gt; &lt;button @click=&quot;add&quot;&gt;添加女朋友&lt;/button&gt; &lt;button @click=&quot;addAge&quot;&gt;添加女朋友年龄&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123;reactive,toRaw,markRaw&#125; from &#x27;vue&#x27;export default &#123; name: &#x27;Home&#x27;, setup()&#123; let names=reactive(&#123; name:&#x27;老伍&#x27;, age:23, job:&#123; salary:10 &#125; &#125;) function addAges()&#123; names.age++ console.log(names) &#125; function addSalary()&#123; let fullName=toRaw(names) fullName.job.salary++ console.log(fullName) &#125; function add()&#123; let girlFriend=&#123;sex:&#x27;女&#x27;,age:40&#125; names.girlFriend=markRaw(girlFriend) &#125; function addAge()&#123; names.girlFriend.age++ console.log(names.girlFriend.age) &#125; return &#123; names, add, addAge, addAges, addSalary &#125; &#125;&#125;&lt;/script&gt;复制代码 customRefcustomRef创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制。 单纯觉得这个东西的作用只有防抖的作用（要是知道其他的用法可以告知一下我） 1234567891011121314151617181920212223242526272829303132333435363738&lt;template&gt; &lt;input type=&quot;text&quot; v-model=&quot;keyWord&quot;&gt; &lt;h3&gt;&#123;&#123;keyWord&#125;&#125;&lt;/h3&gt;&lt;/template&gt;&lt;script&gt;import &#123;customRef&#125; from &#x27;vue&#x27;export default &#123; name: &#x27;App&#x27;, setup() &#123; //自定义一个ref——名为：myRef function myRef(value,times)&#123; let time return customRef((track,trigger)=&gt;&#123; return &#123; get()&#123; console.log(`有人从myRef中读取数据了，我把$&#123;value&#125;给他了`) track() //通知Vue追踪value的变化（必须要有，并且必须要在return之前） return value &#125;, set(newValue)&#123; console.log(`有人把myRef中数据改为了：$&#123;newValue&#125;`) clearTimeout(time) time = setTimeout(()=&gt;&#123; value = newValue trigger() //通知Vue去重新解析模板（必须要有） &#125;,times) &#125;, &#125; &#125;) &#125; let keyWord = myRef(&#x27;HelloWorld&#x27;,1000) //使用自定义的ref return &#123;keyWord&#125; &#125;&#125;&lt;/script&gt;复制代码 给你们说个趣事吧，顺便你们讲一下防抖节流的区别，之前有人在我公司面试的时候哈，给我说对项目进行了防抖节流处理，但是我细问防抖与节流的区别时却支支吾吾的，就很尴尬，然后我们就心照不宣的跳过了这个话题🤣🤣🤣 我是这样理解的 防抖：在第一次触发事件时，不立即执行函数，而是给出一个时间段，如果短时间内大量触发同一事件，只会执行一次函数。 节流：函数执行一次后，在某个时间段内暂时失效，过了这段时间后再重新激活，如果短时间内大量触发同一事件，那么在函数执行一次之后，该函数在指定的时间期限内不再生效，直至过了这段时间才重新生效。（可以理解为游戏技能冷却期） 如果还是不是很能理解的话去看大佬的 一杯茶的时间🍵，带你彻底学会手写防抖节流 provide 与 inject都知道组件传值吧，在vue2中，如果要在后代组件中使用父组件的数据，那么要一层一层的父子组件传值或者用到vuex，但是现在，无论组件层次结构有多深，父组件都可以作为其所有子组件的依赖提供者。这个特性有两个部分：父组件有一个 provide 选项来提供数据，子组件有一个 inject 选项来开始使用这些数据。 1234567891011121314//父import &#123; provide &#125; from &#x27;vue&#x27;setup()&#123; let fullname = reactive(&#123;name:&#x27;阿月&#x27;,salary:&#x27;15k&#x27;&#125;) provide(&#x27;fullname&#x27;,fullname) //给自己的后代组件传递数据 return &#123;...toRefs(fullname)&#125;&#125;//后代import &#123;inject&#125; from &#x27;vue&#x27;setup()&#123; let fullname = inject(&#x27;fullname&#x27;) return &#123;fullname&#125;&#125;复制代码 当然子组件也可以用，但是请记住，父子组件传参是有方法的！！！别瞎搞。 响应式判断下面是vue3给的一些判断方法 isRef: 检查值是否为一个 ref 对象。 isReactive：检查对象是否是由 reactive 创建的响应式代理。 isReadonly: 检查对象是否是由 readonly 创建的只读代理。 isProxy：检查对象是否是由 reactive 或 readonly 创建的 proxy。 1234567891011121314151617import &#123;ref, reactive,readonly,isRef,isReactive,isReadonly,isProxy &#125; from &#x27;vue&#x27;export default &#123; name:&#x27;App&#x27;, setup()&#123; let fullName = reactive(&#123;name:&#x27;小唐&#x27;,price:&#x27;20k&#x27;&#125;) let num = ref(0) let fullNames = readonly(fullName) console.log(isRef(num)) console.log(isReactive(fullName)) console.log(isReadonly(fullNames)) console.log(isProxy(fullName)) console.log(isProxy(fullNames)) console.log(isProxy(num)) return &#123;&#125; &#125;&#125;复制代码 有趣的组件Fragment对我而言这个更像是一种概念，它的意思就相当于创建页面时，给了一个虚拟根标签VNode，因为我们知道在vue2里面，我们是有根标签这个概念的，但是到来vue3，它是自动给你创建个虚拟根标签VNode（Fragment）,所以可以不要根标签。好处就是 减少标签层级, 减小内存占用 Teleportteleport 提供了一种有趣的方法，允许我们控制在 DOM 中哪个父节点下渲染了 HTML，而不必求助于全局状态或将其拆分为两个组件。 其实就是可以不考虑你写在什么位置，你可以定义teleport在任意标签里进行定位等（常见操作为模态框），除了body外，还可以写css选择器（id，class） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172//id定位 &lt;teleport to=&quot;#app&quot;&gt; &lt;div class=&quot;four&quot;&gt; &lt;div class=&quot;five&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/teleport&gt;//class定位 &lt;teleport to=&quot;.one&quot;&gt; &lt;div class=&quot;four&quot;&gt; &lt;div class=&quot;five&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/teleport&gt;//示例&lt;template&gt; &lt;div class=&quot;one&quot;&gt; &lt;h1&gt;第一层&lt;/h1&gt; &lt;div class=&quot;two&quot;&gt; &lt;h1&gt;第二层&lt;/h1&gt; &lt;div class=&quot;three&quot;&gt; &lt;h1&gt;第三层&lt;/h1&gt; &lt;teleport to=&quot;body&quot;&gt; &lt;div class=&quot;four&quot;&gt; &lt;div class=&quot;five&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/teleport&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name:&#x27;App&#x27;, setup()&#123; return &#123;&#125; &#125;&#125;&lt;/script&gt;&lt;style lang=&quot;less&quot;&gt;.one&#123; width: 100%; background-color: blue; .two&#123; margin: 20px; background-color: aqua; .three&#123; margin: 20px; background-color: aliceblue; &#125; &#125;&#125;.four&#123; position: absolute; top: 0; bottom: 0; left: 0; right: 0; background-color: rgba(0, 0, 0, 0.5); .five&#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); width: 300px; height: 300px; left: 50%; background-color:#f60; &#125;&#125;&lt;/style&gt;复制代码 打开控制台然后触发事件，观看效果 Suspense大家都知道在渲染组件之前进行一些异步请求是很常见的事，suspense 组件提供了一个方案，允许将等待过程提升到组件树中处理，而不是在单个组件中。但是！！！在vue3中特别说明了，Suspense 是一个试验性的新特性，其 API 可能随时会发生变动。特此声明，以便社区能够为当前的实现提供反馈。，我直接尬住，以后估计会发生改变，但是你们愿意卷的话可以去看文章vue3的传送门teleport究竟有多神奇？suspense发起异步请求有多简约？，嗯，记得写800字观后感 vue3其他改动router可能大家会想到路由跳转的问题，可能大家会以为还是用this.$router.push来进行跳转，但是哦，在vue3中，这些东西是没有的，它是定义了一个vue-router然后引入的useRoute,useRouter 相当于vue2的 this.$route，this.$router,然后其他之前vue2的操作都可以进行 123456789101112131415import &#123;useRouter,useRoute&#125; from &quot;vue-router&quot;;setup()&#123; const router= useRouter() const route= useRoute() function fn()&#123; this.$router.push(&#x27;/about&#x27;) &#125; onMounted(()=&gt;&#123; console.log(route.query.code) &#125;) return&#123; fn &#125;&#125;复制代码 全局API的转移 2.x 全局 API（Vue） 3.x 实例 API (app) Vue.config.xxxx app.config.xxxx Vue.config.productionTip 移除 Vue.component app.component Vue.directive app.directive Vue.mixin app.mixin Vue.use app.use Vue.prototype app.config.globalProperties 其他改变移除keyCode作为 v-on 的修饰符，同时也不再支持config.keyCodes 移除v-on.native修饰符 移除过滤器（filter） … 对了有手痒的想实战项目的话可以去看一看大佬的🎉🎉Vue 3 + Element Plus + Vite 2 的后台管理系统开源啦🎉🎉 🎉🎉完结撒花🎉🎉在这里感谢各位大佬们的vue3讲解，感谢他们的大力支持！！！ 感谢蒙古海军对本栏目的大力支持。蒙古海军：’我们要征服的可是星辰大海！’ 感谢素未谋面的女友对本栏目的大力支持。’躲猫猫是吧？你藏这么隐蔽我怎么去找？快给我留线索！！！立刻马上！’","categories":[],"tags":[]}],"categories":[],"tags":[]}